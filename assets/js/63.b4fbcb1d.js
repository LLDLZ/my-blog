(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{481:function(e,v,_){"use strict";_.r(v);var s=_(2),r=Object(s.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"手写-promise-一-a-规范介绍以及运行-promise-测试脚本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#手写-promise-一-a-规范介绍以及运行-promise-测试脚本"}},[e._v("#")]),e._v(" 手写 promise （ 一 ）A+ 规范介绍以及运行 Promise 测试脚本")]),e._v(" "),v("h2",{attrs:{id:"了解-promise-a-规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#了解-promise-a-规范"}},[e._v("#")]),e._v(" 了解 promise A+ 规范")]),e._v(" "),v("h3",{attrs:{id:"promise-a-规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#promise-a-规范"}},[e._v("#")]),e._v(" Promise A+ 规范")]),e._v(" "),v("blockquote",[v("ul",[v("li",[e._v("所有的 promise 实现都遵循该规则。")]),e._v(" "),v("li",[e._v("详细 "),v("a",{attrs:{href:"https://promisesaplus.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("promise A+ 规范"),v("OutboundLink")],1),e._v(" 这里引用其他人的中文翻译")]),e._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/Yangfan2016/learn-translate/blob/master/1-Promises-A%2B_zh.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("译文地址"),v("OutboundLink")],1)]),e._v(" "),v("li",[e._v("译文作者 ： "),v("a",{attrs:{href:"https://github.com/Yangfan2016",target:"_blank",rel:"noopener noreferrer"}},[e._v("Yangfan2016"),v("OutboundLink")],1)])])]),e._v(" "),v("p",[v("strong",[e._v("一个开放标准，对于开发人员可互操作的 JavaScript 承诺")])]),e._v(" "),v("p",[e._v("一个 promise 代表一个异步操作的最终结果。主要的操作方式是通过调用 promise 的 "),v("code",[e._v("then")]),e._v(" 方法，它接受的回调函数接受 promise 成功的结果或失败的原因")]),e._v(" "),v("p",[e._v("这个规范详细的描述了 "),v("code",[e._v("then")]),e._v(" 方法的行为，提供一个互操作基础，所有符合 Promises/A+ 的都可以依赖这个标准实现。因此，该规范已经十分稳定。尽管 Promises/A+ 组织可能会偶尔修改以实现向后兼容，我们也会整合这些大的或不能向后兼容的改变，一起研究，讨论，测试。")]),e._v(" "),v("p",[e._v("曾经， Promises/A+ 解释了早期 PromisesA 提议的条款，扩展了事实上的行为和忽略了不标准和有问题的部分。")]),e._v(" "),v("p",[e._v("最终，Promises/A+ 规范并没处理如何创建 fulfill，或 reject promise，而选择了可互操作的 "),v("code",[e._v("then")]),e._v(" 方法替代。在今后的工作中可能会考虑。")]),e._v(" "),v("h3",{attrs:{id:"_1-术语"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-术语"}},[e._v("#")]),e._v(" 1. 术语")]),e._v(" "),v("p",[e._v("1.1 ‘promise’ 是一个有符合此标准的 "),v("code",[e._v("then")]),e._v(" 方法的 "),v("code",[e._v("object")]),e._v(" 或 "),v("code",[e._v("function")])]),e._v(" "),v("p",[e._v("1.2 ‘thenable’ 是 "),v("code",[e._v("then")]),e._v(" 方法定义的 "),v("code",[e._v("object")]),e._v(" 或 "),v("code",[e._v("function")])]),e._v(" "),v("p",[e._v("1.3 ‘value’ 是一个 JavaScript 合法值（包括 "),v("code",[e._v("undefined")]),e._v("，thenable，promise）")]),e._v(" "),v("p",[e._v("1.4 ‘exception’ 是一个 "),v("code",[e._v("throw")]),e._v(" 语句抛出错误的值")]),e._v(" "),v("p",[e._v("1.5 ‘reason’ 是一个表明 promise 失败的原因的值")]),e._v(" "),v("h3",{attrs:{id:"_2-要求"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-要求"}},[e._v("#")]),e._v(" 2. 要求")]),e._v(" "),v("h4",{attrs:{id:"_2-1-promise-状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-promise-状态"}},[e._v("#")]),e._v(" 2.1 Promise 状态")]),e._v(" "),v("p",[e._v("一个 promise 有且只有一个状态（pending，fulfilled，rejected 其中之一）")]),e._v(" "),v("p",[e._v("2.1.1 pending 状态时：")]),e._v(" "),v("ul",[v("li",[e._v("2.1.1.1 可能会转变为 fulfilled 或 rejected 状态")])]),e._v(" "),v("p",[e._v("2.1.2 fulfilled 状态时：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.1.2.1 不能再状态为任何其他状态")])]),e._v(" "),v("li",[v("p",[e._v("2.1.2.2 必须有一个 value，且不可改变")])])]),e._v(" "),v("p",[e._v("2.1.3 rejected 状态时：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.1.3.1 不能再状态为任何其他状态")])]),e._v(" "),v("li",[v("p",[e._v("2.1.3.2 必须有一个 reason，且不可改变")])])]),e._v(" "),v("p",[e._v("注：这里 ‘不可改变’ 意思是不可变恒等（同理 === ），但不意味永远不可变")]),e._v(" "),v("h4",{attrs:{id:"_2-2-then-方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-then-方法"}},[e._v("#")]),e._v(" 2.2 then 方法")]),e._v(" "),v("p",[e._v("一个 promise 必须提供一个 "),v("code",[e._v("then")]),e._v(" 方法，用来获取当前或最终的 value 或 reason")]),e._v(" "),v("p",[e._v("一个 promise 的 "),v("code",[e._v("then")]),e._v(" 方法接受两个参数：")]),e._v(" "),v("p",[v("code",[e._v("promise.then(onFulfilled, onRejected)")])]),e._v(" "),v("p",[e._v("2.2.1 onFulfilled 和 onRejected 都是可选参数：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.2.1.1 如果 onFulfilled 不是函数，它会被忽略")])]),e._v(" "),v("li",[v("p",[e._v("2.2.1.2 如果 onRejected 不是函数，它会被忽略")])])]),e._v(" "),v("p",[e._v("2.2.2 如果 onFulfilled 是一个函数：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.2.2.1 它一定是在 promise 是 fulfilled 状态后调用，并且接受一个参数 value")])]),e._v(" "),v("li",[v("p",[e._v("2.2.2.2 它一定是在 promise 是 fulfilled 状态后调用")])]),e._v(" "),v("li",[v("p",[e._v("2.2.2.3 它最多被调用一次")])])]),e._v(" "),v("p",[e._v("2.2.3 如果 onRejected 是一个函数：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.2.3.1 它一定在 promise 是 rejected 状态后调用，并且接受一个参数 reason")])]),e._v(" "),v("li",[v("p",[e._v("2.2.3.2 它一定在 promise 是 rejected 状态后调用")])]),e._v(" "),v("li",[v("p",[e._v("2.2.3.3 它最多被调用一次")])])]),e._v(" "),v("p",[e._v("2.2.4 onFulfilled 或 onRejected 只在执行环境堆栈只包含平台代码之后调用 [3.1]")]),e._v(" "),v("p",[e._v("2.2.5 onFulfilled 和 onRejected 会作为函数形式调用 (也就是说，默认 "),v("code",[e._v("this")]),e._v(" 指向 global，严格模式 "),v("code",[e._v("undefined")]),e._v(") [3.2]")]),e._v(" "),v("p",[e._v("2.2.6  promise 的 "),v("code",[e._v("then")]),e._v(" 可以链式调用多次")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.2.6.1 如果或当 promise 转态是 fulfilled 时，所有的 onFulfilled 回调回以他们注册时的顺序依次执行")])]),e._v(" "),v("li",[v("p",[e._v("2.2.6.2 如果或当 promise 转态是 rejected 时，所有的 onRejected 回调回以他们注册时的顺序依次执行")])])]),e._v(" "),v("p",[e._v("2.2.7 then 方法一定返回一个 promise")]),e._v(" "),v("p",[v("code",[e._v("promise2 = promise1.then(onFulfilled, onRejected);")])]),e._v(" "),v("ul",[v("li",[e._v("2.2.7.1 如果 onFulfilled 或 onRejected 返回的是一个 x，那么它会以")])]),e._v(" "),v("p",[v("code",[e._v("[[Resolve]](promise2, x)")]),e._v(" 处理解析")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.2.7.2 如果 onFulfilled 或 onRejected 里抛出了一个异常，那么 promise2 必须捕获这个错误（接受一个 reason 参数）")])]),e._v(" "),v("li",[v("p",[e._v("2.2.7.3 如果 onFulfilled 不是一个函数，并且 promise1 状态是 fulfilled，那么 promise2 一定会接受到与 promse1 一样的值 value")])]),e._v(" "),v("li",[v("p",[e._v("2.2.7.4 如果 onRejected 不是一个函数，并且 promise1 状态是 rejected，promise2 一定会接受到与 promise1 一样的值 reason")])])]),e._v(" "),v("h4",{attrs:{id:"_2-3-promise-处理程序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-promise-处理程序"}},[e._v("#")]),e._v(" 2.3 Promise 处理程序")]),e._v(" "),v("p",[e._v("promise 处理程序是一个表现形式为 [[Resolve]](promise, x) 的抽象处理操作。如果 x 是 thenable 类型，它会尝试生成一个 promise 处理 x，否则它将直接 resolve x")]),e._v(" "),v("p",[e._v("只要 then 方法符合 Promises/A+ 规则，那么对 thenables 处理就允许实现可互操作（链式调用，层层传递下去）。它也允许对那些不符合 Promises/A+ 的 then 方法进行 “吸收”")]),e._v(" "),v("p",[v("code",[e._v("[[Resolve]](promise, x)")]),e._v(" 的执行表现形式如下步骤：")]),e._v(" "),v("p",[e._v("2.3.1 如果返回的 promise1 和 x 是指向同一个引用（循环引用），则抛出错误")]),e._v(" "),v("p",[e._v("2.3.2 如果 x 是一个 promise 实例，则采用它的状态：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.3.2.1 如果 x 是 pending 状态，那么保留它（递归执行这个 promise 处理程序），直到 pending 状态转为 fulfilled 或 rejected 状态")])]),e._v(" "),v("li",[v("p",[e._v("2.3.2.2 如果或当 x 状态是 fulfilled，resolve 它，并且传入和 promise1 一样的值 value")])]),e._v(" "),v("li",[v("p",[e._v("2.3.2.3 如果或当 x 状态是 rejected，reject 它，并且传入和 promise1 一样的值 reason")])])]),e._v(" "),v("p",[e._v("2.3.3 此外，如果 x 是个对象或函数类型")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.3.3.1 把 "),v("code",[e._v("x.then")]),e._v(" 赋值给 "),v("code",[e._v("then")]),e._v(" 变量")])]),e._v(" "),v("li",[v("p",[e._v("2.3.3.2 如果捕获（"),v("code",[e._v("try")]),e._v("，"),v("code",[e._v("catch")]),e._v("）到 "),v("code",[e._v("x.then")]),e._v(" 抛出的错误的话，需要 reject 这个promise")])]),e._v(" "),v("li",[v("p",[e._v("2.3.3.3 如果 "),v("code",[e._v("then")]),e._v(" 是函数类型，那个用 x 调用它（将 "),v("code",[e._v("then")]),e._v(" 的 "),v("code",[e._v("this")]),e._v(" 指向 x）,第一个参数传 resolvePromise ，第二个参数传 rejectPromise：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.3.3.3.1 如果或当 resolvePromise 被调用并接受一个参数 y 时，执行\n"),v("code",[e._v("[[Resolve]](promise, y)")])])]),e._v(" "),v("li",[v("p",[e._v("2.3.3.3.2 如果或当 rejectPromise 被调用并接受一个参数 r 时，执行 reject(r)")])]),e._v(" "),v("li",[v("p",[e._v("2.3.3.3.3 如果 resolvePromise 和 rejectPromise 已经被调用或以相同的参数多次调用的话吗，优先第一次的调用，并且之后的调用全部被忽略（避免多次调用）")])]),e._v(" "),v("li",[v("p",[e._v("2.3.3.4 如果 "),v("code",[e._v("then")]),e._v(" 执行过程中抛出了异常，")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("2.3.3.3.4.1 如果 resolvePromise 或 rejectPromise 已经被调用，那么忽略异常")])]),e._v(" "),v("li",[v("p",[e._v("2.3.3.3.4.2 否则，则 reject 这个异常")])])])])])]),e._v(" "),v("li",[v("p",[e._v("2.3.3.4 如果 "),v("code",[e._v("then")]),e._v(" 不是函数类型，直接 resolve x（resolve(x)）")])])]),e._v(" "),v("p",[e._v("2.3.4 如果 x 即不是函数类型也不是对象类型，直接 resolve x（resolve(x)）")]),e._v(" "),v("p",[e._v("如果被 resolve 的 promise 参与了 thenable 的循环链中，那么可能会导致无限递归。我们鼓励实现检测这种无限递归的方法并且返回一个错误信息，但并不是必须的 [3.6]")]),e._v(" "),v("h3",{attrs:{id:"_3-备注"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-备注"}},[e._v("#")]),e._v(" 3. 备注")]),e._v(" "),v("p",[e._v("3.1 这里的 “平台代码”是指引擎，环境，和 promise 实现代码。实际上，这个要求确保 onFulfilled 和 onRejected 都在下一轮的事件循环中（一个新的栈）被异步调用。可以用宏任务，例如："),v("code",[e._v("setTimeout")]),e._v("，"),v("code",[e._v("setImmediate")]),e._v(" 或者微任务，例如："),v("code",[e._v("MutationObsever")]),e._v(" 或 "),v("code",[e._v("process.nextTick")]),e._v(" 实现。 由于 promise 的实现被当做平台代码，所以它本身可能包含一个任务队列或 “trampoline” 的处理程序")]),e._v(" "),v("p",[e._v("3.2 这个 "),v("code",[e._v("this")]),e._v(" 在严格模式下是 "),v("code",[e._v("undefined")]),e._v("，在宽松模式，指向 global 对象")]),e._v(" "),v("p",[e._v("3.3 具体的实现可以允许 promise2 和 promise1 绝对相等，要满足所有要求。每一个处理 promise2 和 promise1 绝对相等的实现都要写上文档标注")]),e._v(" "),v("p",[e._v("3.4 通常，只有它来自当前实现才可以判断 x 是一个真正的 promise。 此条款允许采取已知符合 promise 标准实现的状态")]),e._v(" "),v("p",[e._v("3.5 把 "),v("code",[e._v("x.then")]),e._v(" 存起来，然后测试、调用这个引用，避免多次访问 "),v("code",[e._v("x.then")]),e._v(" 属性。这么做的原因是防止每次获取 "),v("code",[e._v("x.then")]),e._v(" 时，返回不同的情况（"),v("code",[e._v("ES5")]),e._v(" 的 "),v("code",[e._v("getter")]),e._v(" 特性可能会产生副作用）")]),e._v(" "),v("p",[e._v("3.6 实现不应该武断地限制 thenable 链的深度，假设超出限制的无限递归。只有真正的循环引用才会导致一个 "),v("code",[e._v("TypeError")]),e._v(" 错误，如果遇到一个不同的无限递归 thenable 链，一直递归永远是正确的行为")]),e._v(" "),v("h2",{attrs:{id:"关于自己手写的-promise-是否规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于自己手写的-promise-是否规范"}},[e._v("#")]),e._v(" 关于自己手写的 promise 是否规范")]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("promises-aplus-tests")]),e._v(" 是官方的测试库\n使用 npm 库 promises-aplus-tests -g 来测试自己的 promise 是否符合规范")])]),e._v(" "),v("h3",{attrs:{id:"安装"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[e._v("#")]),e._v(" 安装")]),e._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[v("span",{pre:!0,attrs:{class:"token function"}},[e._v("npm")]),e._v(" i promises-aplus-tests "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-g")]),e._v("\n")])])]),v("h3",{attrs:{id:"使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[e._v("#")]),e._v(" 使用")]),e._v(" "),v("ul",[v("li",[e._v("进入自己写的 promise 目录")])]),e._v(" "),v("div",{staticClass:"language-bash extra-class"},[v("pre",{pre:!0,attrs:{class:"language-bash"}},[v("code",[e._v("promises-aplus-tests promise.js\n")])])]),v("h2",{attrs:{id:"promise-优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#promise-优缺点"}},[e._v("#")]),e._v(" promise 优缺点")]),e._v(" "),v("ul",[v("li",[e._v("优点\n"),v("ul",[v("li",[e._v("可以解决回调地狱")]),e._v(" "),v("li",[e._v("可以解决多个异步并发的问题")])])]),e._v(" "),v("li",[e._v("缺点\n"),v("ul",[v("li",[e._v("promise 还是基于回调函数")])])])])])}),[],!1,null,null,null);v.default=r.exports}}]);