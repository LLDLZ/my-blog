# Vue2.x 源码解析（三）Vue 异步更新原理
## dep.notify
> `/src/core/observer/dep.js`
```js
/**
 * 通知 dep 中的所有 watcher，执行 watcher.update() 方法
 */
notify () {
  // stabilize the subscriber list first
  const subs = this.subs.slice()
  // 遍历 dep 中存储的 watcher，执行 watcher.update()
  for (let i = 0, l = subs.length; i < l; i++) {
    subs[i].update()
  }
}
```
## watcher.update
> `/src/core/observer/watcher.js`
```js
update () {
    /* istanbul ignore else */
    if (this.lazy) {
      // 懒执行时会走这，比如 computed 
      // 将 dirty 置为 true，在组件更新后，当响应式数据再次更新时，执行 computed getter 重新执行 computed 回调函数，计算新值，然后缓存到 watcher.value 里 
      this.dirty = true
    } else if (this.sync) {
      // 同步执行
      // ex： this.$watch() 或者 watcher 选项时，传递一个 sync 配置  比如 { sync : true  }
      this.run()
    } else {
      // 将 watcher 放入 watcher 队列，一般都是走这个分支
      queueWatcher(this)
    }
  }
```




## 总结
### Vue 的异步更新机制是如何实现的？
### Vue 的 nextTick API 是如何实现的？
## 思维导图

> [看不清楚？点击这里](https://lldlz.github.io/my-blog/assets/img/blog/vue2CodeAnalysis/Vue异步更新.png)

<img :src="$withBase('/assets/img/blog/vue2CodeAnalysis/Vue异步更新.png')">
